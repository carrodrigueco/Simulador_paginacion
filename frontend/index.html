<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Simulador Paginacion - Cyberpunk</title>
    <link rel="stylesheet" href="./css/style.css">
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&family=Share+Tech+Mono&display=swap" rel="stylesheet">
</head>
<body>
    <div class="cyber-glow-bg"></div>
    <div class="animated-shapes-container">
        <div class="shape shape-1"></div>
        <div class="shape shape-2"></div>
        <div class="shape shape-3"></div>
        <div class="shape shape-4"></div>
        <div class="shape shape-5"></div>
    </div>

    <h1>Simulador de Algoritmos de Reemplazo de Páginas</h1>

    <main class="container">

        <button class="user-manual-button glow-on-hover" @click="toggleManual">Manual de Usuario</button>

        <section id="algoritmos-info" class="cyber-panel slide-in-top">
            <h2 class="section-title cyber-text-glow">Información de Algoritmos</h2>
            <div class="algoritmo-card">
                <h3>Algoritmo FIFO (First-In, First-Out)</h3>
                <p>FIFO es el algoritmo de reemplazo de páginas más simple. Cuando una página necesita ser reemplazada, se elige la página que lleva más tiempo en la memoria. Es como una cola de espera: el primero en entrar es el primero en salir. Su implementación es sencilla, pero su eficiencia puede ser limitada, ya que una página muy utilizada pero antigua podría ser desalojada.</p>
            </div>
            <div class="algoritmo-card">
                <h3>Algoritmo LRU (Least Recently Used)</h3>
                <p>LRU es un algoritmo más sofisticado. Reemplaza la página que no ha sido utilizada durante el mayor período de tiempo. Se basa en la idea de que las páginas que se han utilizado recientemente son más propensas a ser utilizadas de nuevo en el futuro. Es más eficiente que FIFO pero más complejo de implementar.</p>
            </div>
        </section>

        <section id="Input-secuencia" class="cyber-panel slide-in-top delay-1">
            <div class="input-group">
                <label for="Seccion-botones" class="cyber-text-glow">Oprima el botón de la página que desea agregar a la fila:</label>
                <div class="Seccion-botones">
                    <button class="Input-button verde" @click="AgregarPagina('1', 'verde')">1</button>
                    <button class="Input-button verde-claro" @click="AgregarPagina('2', 'verde-claro')">2</button>
                    <button class="Input-button amarillo-verdoso" @click="AgregarPagina('3', 'amarillo-verdoso')">3</button>
                    <button class="Input-button amarillo" @click="AgregarPagina('4', 'amarillo')">4</button>
                    <button class="Input-button naranja" @click="AgregarPagina('5', 'naranja')">5</button>
                    <button class="Input-button rojo" @click="AgregarPagina('6', 'rojo')">6</button>
                </div>
            </div>
        </section>

        <section id="Output-secuencia" class="cyber-panel slide-in-top delay-2">
            <p class="cyber-text-glow section-subtitle">Secuencia escogida:</p>
            <div id="Paginas-secuencia">
                <div v-for="(pagina, index) in paginas" class="page-box pulse-animation" :class="pagina.color">
                    <p>{{ pagina.pagina }}</p>
                    <button class="close-btn" @click="RetirarPagina(index)">X</button>
                </div>
            </div>
            <p v-if="mensaje_limite" class="error-message flicker-animation">¡LÍMITE DE PÁGINAS ALCANZADO!</p>
            <div class="button-wrapper">
                <button class="boton-simular glow-on-hover" @click="Simular">SIMULAR</button>
            </div>
        </section>

        <section id="Results-secuencia" class="cyber-panel slide-in-top delay-3">
            <h2 class="section-title cyber-text-glow">Resultados de la Simulación</h2>
            <div class="simulation-controls">
                <button class="control-button play-button" @click="playSimulation">Reproducir</button>
                <button class="control-button pause-button" @click="pauseSimulation">Pausar</button>
                <button class="control-button reset-button" @click="resetSimulation">Reiniciar</button>
                <label for="speed-slider" class="cyber-text-glow">Velocidad:</label>
                <input type="range" id="speed-slider" min="100" max="2000" v-model="simulation_speed" @input="updateSimulationSpeed">
            </div>
            <div class="results-grid">
                <div class="algorithm-results">
                    <h3>FIFO</h3>
                    <div class="frames-container simulation-table-container">
                        <table class="simulation-table">
                            <thead>
                                <tr>
                                    <th>Tiempo</th>
                                    <th>Referencia</th>
                                    <th v-for="n in 4" :key="'fifo-m' + n">M{{ n }}</th>
                                    <th>Fallos</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr v-for="(step, index) in fifo_steps.slice(0, current_fifo_step_index + 1)" :key="'fifo-step-table-' + index"
                                    :class="{ 'current-step': index === current_fifo_step_index, 'fault-row': step.fault }">
                                    <td>{{ index + 1 }}</td>
                                    <td :class="{ 'fault-cell': step.fault }">{{ step.page }}</td>
                                    <td v-for="(frame, f_idx) in step.frames" :key="'fifo-frame-cell-' + index + '-' + f_idx">
                                        {{ frame == null ? '' : frame }}
                                    </td>
                                    <td>
                                        <span v-if="step.fault" class="table-fault-indicator">F</span>
                                    </td>
                                </tr>
                                <tr v-if="fifo_steps.length === 0 || current_fifo_step_index === -1">
                                    <td colspan="7" class="empty-results-message">Presiona SIMULAR y luego Reproducir para ver la simulación.</td>
                                </tr>
                            </tbody>
                        </table>
                    </div>
                    <p class="fault-count">Fallos de página: <span class="count-value">{{ fifo_faults }}</span></p>
                </div>
                <div class="algorithm-results">
                    <h3>LRU</h3>
                    <div class="frames-container simulation-table-container">
                        <table class="simulation-table">
                            <thead>
                                <tr>
                                    <th>Tiempo</th>
                                    <th>Referencia</th>
                                    <th v-for="n in 4" :key="'lru-m' + n">M{{ n }}</th>
                                    <th>Fallos</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr v-for="(step, index) in lru_steps.slice(0, current_lru_step_index + 1)" :key="'lru-step-table-' + index"
                                    :class="{ 'current-step': index === current_lru_step_index, 'fault-row': step.fault }">
                                    <td>{{ index + 1 }}</td>
                                    <td :class="{ 'fault-cell': step.fault }">{{ step.page }}</td>
                                    <td v-for="(frame, f_idx) in step.frames" :key="'lru-frame-cell-' + index + '-' + f_idx">
                                        {{ frame == null ? '' : frame }}
                                    </td>
                                    <td>
                                        <span v-if="step.fault" class="table-fault-indicator">F</span>
                                    </td>
                                </tr>
                                <tr v-if="lru_steps.length === 0 || current_lru_step_index === -1">
                                    <td colspan="7" class="empty-results-message">Presiona SIMULAR y luego Reproducir para ver la simulación.</td>
                                </tr>
                            </tbody>
                        </table>
                    </div>
                    <p class="fault-count">Fallos de página: <span class="count-value">{{ lru_faults }}</span></p>
                </div>
            </div>
        </section>

    </main>

    <div class="manual-modal-overlay" v-if="showManual" @click.self="toggleManual">
        <div class="manual-modal-content cyber-panel">
            <button class="close-modal-button" @click="toggleManual">X</button>
            <h2 class="section-title cyber-text-glow">Manual de Usuario - Simulador de Paginación</h2>

            <div class="manual-navigation">
                <button class="nav-button" :class="{ 'active': currentManualSection === 'introduccion' }" @click="setManualSection('introduccion')">Introducción</button>
                <button class="nav-button" :class="{ 'active': currentManualSection === 'algoritmos' }" @click="setManualSection('algoritmos')">Algoritmos</button>
                <button class="nav-button" :class="{ 'active': currentManualSection === 'uso-simulador' }" @click="setManualSection('uso-simulador')">Uso del Simulador</button>
                <button class="nav-button" :class="{ 'active': currentManualSection === 'interpretacion' }" @click="setManualSection('interpretacion')">Interpretación</button>
                <button class="nav-button" :class="{ 'active': currentManualSection === 'codigo' }" @click="setManualSection('codigo')">Funcionamiento del Código</button> <button class="nav-button" :class="{ 'active': currentManualSection === 'consideraciones' }" @click="setManualSection('consideraciones')">Consideraciones</button>
            </div>

            <div class="manual-section-content">
                <div v-if="currentManualSection === 'introduccion'">
                    <h3>Bienvenido al Simulador de Algoritmos de Reemplazo de Páginas</h3>
                    <p>Esta aplicación permite visualizar el comportamiento de dos algoritmos fundamentales en la gestión de memoria de sistemas operativos: FIFO (First-In, First-Out) y LRU (Least Recently Used). Podrás definir una secuencia de páginas y observar cómo cada algoritmo gestiona la memoria principal (RAM) a lo largo del tiempo, registrando los fallos de página.</p>
                    <p>Diseñado con una interfaz intuitiva y una estética cyberpunk, este simulador es una herramienta educativa para comprender los conceptos de paginación de memoria de manera práctica y visual.</p>
                </div>

                <div v-if="currentManualSection === 'algoritmos'">
                    <h3>Algoritmos de Reemplazo de Páginas</h3>
                    <h4>1. Algoritmo FIFO (First-In, First-Out)</h4>
                    <p>FIFO es el algoritmo más simple y directo. Cuando la memoria está llena y una nueva página necesita ser cargada, FIFO reemplaza la página que lleva más tiempo en la memoria (la primera que entró). Es como una cola de espera: el primero en entrar es el primero en salir. Su implementación es sencilla, pero su eficiencia puede ser limitada, ya que una página muy utilizada pero antigua podría ser desalojada.</p>
                    <h4>2. Algoritmo LRU (Least Recently Used)</h4>
                    <p>LRU es un algoritmo más complejo y generalmente más eficiente que FIFO. Cuando se necesita reemplazar una página, LRU selecciona aquella que no ha sido utilizada durante el período de tiempo más largo. La premisa es que las páginas usadas recientemente tienen más probabilidades de ser usadas de nuevo en el futuro. Requiere un mecanismo para rastrear el "tiempo" o el uso de cada página.</p>
                </div>

                <div v-if="currentManualSection === 'uso-simulador'">
                    <h3>Uso del Simulador</h3>
                    <ol>
                        <li><strong>Selección de Páginas:</strong> En la sección "Oprima el botón de la página...", haz clic en los botones numerados (1-6) para agregar páginas a tu secuencia. El orden en que las agregues definirá la secuencia de referencias de página.</li>
                        <li><strong>Secuencia Escogida:</strong> Las páginas seleccionadas aparecerán en la sección "Secuencia escogida". Puedes retirar una página de la secuencia haciendo clic en el botón 'X' junto a ella. Existe un límite máximo de páginas para la simulación.</li>
                        <li><strong>Simular:</strong> Una vez que hayas definido tu secuencia, haz clic en el botón "SIMULAR". El sistema procesará la secuencia con ambos algoritmos (FIFO y LRU) y preparará los resultados.</li>
                        <li><strong>Controles de Simulación:</strong> En la sección "Resultados de la Simulación", encontrarás:
                            <ul>
                                <li><strong>Reproducir:</strong> Inicia la visualización paso a paso de la simulación.</li>
                                <li><strong>Pausar:</strong> Detiene la simulación en el paso actual.</li>
                                <li><strong>Reiniciar:</strong> Vuelve al inicio de la simulación.</li>
                                <li><strong>Velocidad:</strong> Un deslizador para ajustar la rapidez con la que avanza la simulación.</li>
                            </ul>
                        </li>
                    </ol>
                </div>

                <div v-if="currentManualSection === 'interpretacion'">
                    <h3>Interpretación de los Resultados</h3>
                    <p>La sección de resultados muestra una tabla para cada algoritmo (FIFO y LRU), con el siguiente formato:</p>
                    <ul>
                        <li><strong>Tiempo:</strong> El número de paso en la secuencia de referencia.</li>
                        <li><strong>Referencia:</strong> La página que se intentó acceder en ese paso. Si la celda y la fila están resaltadas en rosa, indica un "fallo de página" (Page Fault).</li>
                        <li><strong>M1, M2, M3, M4:</strong> Representan los marcos (espacios) de memoria RAM disponibles. El número indica la página actualmente cargada en ese marco.</li>
                        <li><strong>Fallos:</strong> Un indicador 'F' en esta columna significa que en ese paso se produjo un fallo de página, lo que implicó cargar la página deseada desde el disco y posiblemente desalojar otra página de la RAM.</li>
                    </ul>
                    <p>Al final de cada tabla, se muestra el "Total de Fallos de Página", un indicador clave de la eficiencia del algoritmo para una secuencia dada: menos fallos generalmente significan mejor rendimiento.</p>
                </div>

                <div v-if="currentManualSection === 'codigo'">
                    <h3>Estructura y Funcionamiento del Código</h3>
                    <p>Este simulador está dividido en dos partes principales: el <strong>Frontend</strong> (interfaz de usuario) y el <strong>Backend</strong> (lógica de simulación y servidor). La comunicación entre ambos se realiza a través de peticiones HTTP.</p>

                    <h4>1. Estructura de Archivos</h4>
                    <p>El proyecto se organiza de la siguiente manera:</p>
                    <pre><code>
simulador/
├── backend/
│   └── app.py
└── frontend/
    ├── css/
    │   └── style.css
    ├── js/
    │   └── componente.js
    └── index.html
                    </code></pre>
                    <p>Esta estructura modular facilita el desarrollo y la separación de responsabilidades entre el equipo.</p>

                    <h4>2. Frontend (`index.html`, `style.css`, `componente.js`)</h4>
                    <p>El Frontend es la parte visible de la aplicación, construida con HTML, CSS y JavaScript (Petite-Vue).</p>
                    <ul>
                        <li><strong>`index.html` (Estructura y Contenido):</strong> Es el archivo principal que define la estructura de la página. Contiene todas las secciones visibles (información de algoritmos, entrada de secuencia, resultados) y el modal del manual de usuario. Utiliza directivas de Petite-Vue (`v-for`, `v-if`, `@click`, `:class`) para el renderizado dinámico de la interfaz y la interactividad. Incluye enlaces a `style.css` y `componente.js`.</li>
                        <li><strong>`style.css` (Diseño y Estética):</strong> Este archivo es responsable de toda la apariencia visual de la aplicación. Implementa la estética "cyberpunk" mediante:
                            <ul>
                                <li>**Paleta de Colores:** Tonos morados, azules cian y destellos de neón (rosa, verde brillante).</li>
                                <li>**Tipografía:** Fuentes "Orbitron" para títulos y "Share Tech Mono" para texto general, que evocan una sensación futurista.</li>
                                <li>**Efectos Visuales:**
                                    <ul>
                                        <li>**Glassmorphism:** Aplicado a los paneles principales (`.cyber-panel`) con `background-color: rgba(...)` y `backdrop-filter: blur(...) saturate(...)` para crear un efecto de vidrio translúcido.</li>
                                        <li>**Animaciones de Fondo:** El `div.cyber-glow-bg` y las `.shape` animadas (`.animated-shapes-container`) crean un fondo dinámico con luces pulsantes y formas geométricas que se mueven y rotan, añadiendo profundidad y dinamismo.</li>
                                        <li>**Animaciones de Interfaz:** Transiciones (`transition`) y animaciones (`@keyframes`) en botones (efectos de brillo al pasar el ratón), secciones (aparición `slide-in-top`), y elementos de simulación (pulsaciones en celdas activas, parpadeos en mensajes de error).</li>
                                        <li>**Bordes con Gradientes:** Utilización de `border-image` para dar un toque neón a los bordes de los paneles y botones.</li>
                                    </ul>
                                </li>
                                <li>**Diseño Responsivo:** Uso de `@media queries` para adaptar la interfaz a diferentes tamaños de pantalla (móviles, tablets), asegurando una buena experiencia de usuario en cualquier dispositivo.</li>
                            </ul>
                        </li>
                        <li><strong>`componente.js` (Lógica Frontend con Petite-Vue):</strong> Es el cerebro del frontend. Gestiona el estado de la aplicación y la interactividad.
                            <ul>
                                <li><strong>Gestión de Secuencia:</strong> Maneja la adición y eliminación de páginas en la secuencia (`paginas`).</li>
                                <li><strong>Comunicación con Backend:</strong> La función `Simular()` realiza una petición `POST` a la ruta `/simulate` del backend, enviando la secuencia de páginas y esperando los resultados de la simulación.</li>
                                <li><strong>Simulación en Tiempo Real:</strong> Al recibir los resultados, `playSimulation()` utiliza `setInterval()` para avanzar y mostrar los pasos de la simulación uno por uno en la tabla de resultados. Los métodos `pauseSimulation()` y `resetSimulation()` permiten controlar esta reproducción.</li>
                                <li><strong>Control del Manual de Usuario:</strong> Las propiedades `showManual` y `currentManualSection`, junto con los métodos `toggleManual()` y `setManualSection()`, controlan la visibilidad y navegación dentro del manual interactivo.</li>
                            </ul>
                        </li>
                    </ul>

                    <h4>3. Backend (`app.py`)</h4>
                    <p>El Backend, desarrollado con Flask (Python), es responsable de servir los archivos estáticos del frontend y de ejecutar la lógica de simulación de los algoritmos de reemplazo de páginas.</p>
                    <ul>
                        <li><strong>Servidor de Archivos Estáticos:</strong>
                            <ul>
                                <li>Configuración de `Flask`: Se inicializa Flask con `static_folder='../frontend'` y `static_url_path=''` para servir los archivos HTML, CSS y JavaScript directamente desde la carpeta `frontend` sin prefijos URL adicionales.</li>
                                <li>Ruta principal (`@app.route("/")`): Sirve el `index.html` como la página principal.</li>
                            </ul>
                        </li>
                        <li><strong>API de Simulación (`@app.post("/simulate")`):</strong>
                            <ul>
                                <li><strong>Recepción de Datos:</strong> Espera una petición `POST` con una secuencia de páginas en formato JSON.</li>
                                <li><strong>Lógica de Algoritmos:</strong> Contiene la implementación del algoritmo <strong>FIFO (First-In, First-Out)</strong>. Itera sobre la secuencia de páginas, simulando la carga y reemplazo en la RAM. Registra el estado de la RAM, la página de referencia y si hubo un fallo en cada paso.
                                    <br><em>(Nota para el profesor: La implementación del algoritmo LRU por parte de mi compañero está actualmente en desarrollo en esta misma sección y será integrada en breve.)</em></li>
                                <li><strong>Función `pagina_en_ram()`:</strong> Una función auxiliar para verificar si una página ya se encuentra en la memoria RAM.</li>
                                <li><strong>Envío de Resultados:</strong> Una vez completada la simulación, devuelve los resultados (pasos detallados y conteo de fallos para FIFO y LRU) al frontend en formato JSON, listos para su visualización.</li>
                            </ul>
                        </li>
                    </ul>
                    <p>Esta división entre Frontend y Backend permite un desarrollo colaborativo eficiente y una clara separación de la lógica de presentación y la lógica de negocio.</p>
                </div>

                <div v-if="currentManualSection === 'consideraciones'">
                    <h3>Consideraciones Adicionales</h3>
                    <ul>
                        <li>El simulador está configurado con 4 marcos de memoria RAM.</li>
                        <li>La implementación del algoritmo LRU por parte de mi compañero está actualmente en progreso. La tabla LRU mostrará un mock de datos hasta que su lógica esté completa, pero la interfaz ya está lista para su visualización real.</li>
                        <li>Este simulador está diseñado con fines educativos y simplifica ciertos aspectos de la gestión de memoria real para facilitar la comprensión.</li>
                        <li>El diseño está inspirado en la estética cyberpunk para una experiencia visual inmersiva. ¡Disfrútalo!</li>
                    </ul>
                </div>
            </div>
        </div>
    </div>

    <script type="module">
        import { createApp } from 'https://unpkg.com/petite-vue?module'
        import { componente } from './js/componente.js'
        createApp(componente).mount()
    </script>
</body>
</html>